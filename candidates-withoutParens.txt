!=
##
*
+
++
++:
+:
->
/:
:+
:\
<
<=
<init>
==
>
>=
addString
aggregate
andThen
apply
applyOrElse
asInstanceOf
canEqual
capitalize
charAt
chars
clone
codePointAt
codePointBefore
codePointCount
codePoints
collect
collectFirst
combinations
companion
compare
compareTo
compareToIgnoreCase
compose
concat
contains
containsSlice
contentEquals
copyToArray
copyToBuffer
corresponds
count
diff
distinct
drop
dropRight
dropWhile
endsWith
ensuring
eq
equals
equalsIgnoreCase
exists
filter
filterImpl
filterNot
finalize
find
flatMap
flatten
fold
foldLeft
foldRight
forall
foreach
format
formatLocal
formatted
genericBuilder
getBytes
getChars
getClass
groupBy
grouped
hasDefiniteSize
hashCode
head
headOption
indexOf
indexOfSlice
indexWhere
indices
init
inits
intern
intersect
isDefinedAt
isEmpty
isInstanceOf
isTraversableAgain
iterator
last
lastIndexOf
lastIndexOfSlice
lastIndexWhere
lastOption
length
lengthCompare
lift
lines
linesIterator
linesWithSeparators
map
matches
max
maxBy
min
minBy
mkString
ne
newBuilder
nonEmpty
notify
notifyAll
offsetByCodePoints
orElse
padTo
par
parCombiner
partition
patch
permutations
prefixLength
product
r
reduce
reduceLeft
reduceLeftOption
reduceOption
reduceRight
reduceRightOption
regionMatches
replace
replaceAll
replaceAllLiterally
replaceFirst
repr
reverse
reverseIterator
reverseMap
reversed
runWith
sameElements
scan
scanLeft
scanRight
segmentLength
self
seq
size
sizeHintIfCheap
slice
sliceWithKnownBound
sliceWithKnownDelta
sliding
sortBy
sortWith
sorted
span
split
splitAt
startsWith
stringPrefix
stripLineEnd
stripMargin
stripPrefix
stripSuffix
subSequence
substring
sum
synchronized
tail
tails
take
takeRight
takeWhile
thisCollection
to
toArray
toBoolean
toBuffer
toByte
toCharArray
toCollection
toDouble
toFloat
toIndexedSeq
toInt
toIterable
toIterator
toList
toLong
toLowerCase
toMap
toSeq
toSet
toShort
toStream
toString
toTraversable
toUpperCase
toVector
transpose
trim
union
unzip
unzip3
updated
view
wait
withFilter
zip
zipAll
zipWithIndex
â†’