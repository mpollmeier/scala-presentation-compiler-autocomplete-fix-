*
+
++
++:
+:
/:
:+
:\
<
<=
>
>=
addString
aggregate
andThen
apply
applyOrElse
canEqual
capitalize
charAt
chars
codePointAt
codePointBefore
codePointCount
codePoints
collect
collectFirst
combinations
companion
compare
compareTo
compareToIgnoreCase
compose
concat
contains
containsSlice
contentEquals
copyToArray
copyToBuffer
corresponds
count
diff
distinct
drop
dropRight
dropWhile
endsWith
equals
equalsIgnoreCase
exists
filter
filterNot
find
flatMap
flatten
fold
foldLeft
foldRight
forall
foreach
format
formatLocal
genericBuilder
getBytes
getChars
groupBy
grouped
hasDefiniteSize
hashCode
head
headOption
indexOf
indexOfSlice
indexWhere
indices
init
inits
intern
intersect
isDefinedAt
isEmpty
isTraversableAgain
iterator
last
lastIndexOf
lastIndexOfSlice
lastIndexWhere
lastOption
length
lengthCompare
lift
lines
linesIterator
linesWithSeparators
map
matches
max
maxBy
min
minBy
mkString
nonEmpty
offsetByCodePoints
orElse
padTo
par
partition
patch
permutations
prefixLength
product
r
reduce
reduceLeft
reduceLeftOption
reduceOption
reduceRight
reduceRightOption
regionMatches
replace
replaceAll
replaceAllLiterally
replaceFirst
repr
reverse
reverseIterator
reverseMap
runWith
sameElements
scan
scanLeft
scanRight
segmentLength
self
seq
size
slice
sliding
sortBy
sortWith
sorted
span
split
splitAt
startsWith
stringPrefix
stripLineEnd
stripMargin
stripPrefix
stripSuffix
subSequence
substring
sum
tail
tails
take
takeRight
takeWhile
to
toArray
toBoolean
toBuffer
toByte
toCharArray
toDouble
toFloat
toIndexedSeq
toInt
toIterable
toIterator
toList
toLong
toLowerCase
toMap
toSeq
toSet
toShort
toStream
toString
toTraversable
toUpperCase
toVector
transpose
trim
union
unzip
unzip3
updated
view
withFilter
zip
zipAll
zipWithIndex